
variables:
  #########################################
  # Required BSG Variables
  #########################################
  USER_NAME: "${BSG_CI_USER_NAME}"
  USER_ID: "${BSG_CI_USER_ID}"
  GROUP_NAME: "${BSG_CI_GROUP_NAME}"
  GROUP_ID: "${BSG_CI_GROUP_ID}"
  OTHER_GROUPS: "${BSG_CI_OTHER_GROUPS}"
  CORES_PER_JOB: "${BSG_CI_CORES_PER_JOB}"
  WORKDIR: "${BSG_CI_WORKDIR}"
  #########################################
  # Optional BSG Variables
  #########################################
  FORCE_REBUILD: "${BSG_CI_FORCE_REBUILD}"
  #########################################
  # GitLab Variables
  #########################################
  # Automatic; we save them as "documentation"
  BUILDS: "${CI_BUILDS_DIR}"
  BRANCH: "${CI_COMMIT_REF_SLUG}"
  COMMIT_REF: "${CI_COMMIT_REF_NAME}"
  REPOSITORY_URL: "${CI_REPOSITORY_URL}"
  SHA: "${CI_COMMIT_SHA}"
  REPO_NAME: "${CI_PROJECT_NAME}"
  JOB_NAME: "${CI_JOB_NAME_SLUG}"
  REGISTRY: "${CI_REGISTRY}"
  REGISTRY_USER: "${CI_REGISTRY_USER}"
  REGISTRY_IMAGE: "${CI_REGISTRY_IMAGE}"
  REGISTRY_PASSWORD: "${CI_REGISTRY_PASSWORD}"
  JOB_TOKEN: "${CI_JOB_TOKEN}"
  PROJECT_ID: "${CI_PROJECT_ID}"
  API_URL: "${CI_API_V4_URL}"
  # workaround for https://gitlab.com/gitlab-org/gitlab/-/issues/386967
  GIT_CONFIG_COUNT: 1
  GIT_CONFIG_KEY_0: "safe.directory"
  GIT_CONFIG_VALUE_0: "*"
  # Performance flags https://docs.gitlab.com/runner/configuration/feature-flags/
  FF_USE_FASTZIP: "true"
  #ARTIFACT_COMPRESSION_LEVEL: "fastest"
  #CACHE_COMPRESSION_LEVEL: "fastest"
  # Enable docker caching
  DOCKER_BUILDKIT: "1"
  DOCKER_DRIVER: overlay2
  #########################################
  # Generated Global Variables
  #########################################
  CONTAINER_IMAGE: "${REGISTRY_IMAGE}:${DOCKER_PLATFORM}" # Container per-platform

###################################################
## Workflow
###################################################

# Currently only run on pushes, merge requests do not run separately
workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"

stages:
  - docker
  - build
  - publish

###################################################
## Anchors
###################################################

.git_anchors:
  variables: &git_variables
    # Builtin
    GET_SOURCES_ATTEMPTS: 3
    # Lockfile variables
    GIT_LOCKDIR: "ci.git.lock"
    GIT_LOCKDIR_ATTEMPTS: 100
    GIT_LOCKDIR_TIMEOUT: 10
    GIT_SRC_DIR: "${GIT_CLONE_PATH}/src"
    GIT_CLONE_FLAGS: "--single-branch --depth=5 --progress"
  git_fetch: &git_fetch_script
    - |
      if [ -d "${GIT_SRC_DIR}" ]; then
        echo "[CI] git directory already exists, skipping clone..."
        git -C ${GIT_SRC_DIR} fetch origin ${COMMIT_REF}
      else
        echo "[CI] git directory does not exist, cloning..."
        git clone -b ${COMMIT_REF} ${GIT_CLONE_FLAGS} ${REPOSITORY_URL} ${GIT_SRC_DIR}
      fi
  git_checkout: &git_checkout_script
    - export CURRENT_SHA=$(git -C ${GIT_SRC_DIR} rev-parse HEAD)
    - |
      if [ ${CURRENT_SHA} != ${SHA} ]; then
        echo "[CI] repo is currently on ${CURRENT_SHA}, checking out ${SHA}"
        git -C ${GIT_SRC_DIR} checkout ${SHA}
      fi
    - git -C ${GIT_SRC_DIR} submodule update --init
  git_lock: &git_lock_script
    - |
      for ((i = 1; i <= $GIT_LOCKDIR_ATTEMPTS; i++)); do
        if mkdir $GIT_LOCKDIR 2>/dev/null; then
          echo "[CI] Acquired lock on attempt $i!"
          break
        else
          echo "[CI] Lock in use, attempt $i of $GIT_LOCKDIR_ATTEMPTS..."
          sleep ${GIT_LOCKDIR_TIMEOUT}
        fi
      done
  git_unlock: &git_unlock_script
    - |
      echo "[CI] Removing lock"
      rmdir "${GIT_LOCKDIR}"
  git_unlock_fs: &git_unlock_fs_script
    - |
      if [ $CI_JOB_STATUS == 'failure' ]; then
        echo "[CI] Removing lock (failsafe)"
        rm -rf "${GIT_LOCKDIR}"
      fi

###################################################
## Mixins
###################################################

.git_mixin:
  variables:
    <<: *git_variables

.bare_mixin:
  extends: [.git_mixin]
  variables:
    # Built-in
    GIT_STRATEGY: "none"
    GIT_SUBMODULE_STRATEGY: "none"
    GIT_CLEAN_FLAGS: "none"

.clone_mixin:
  extends: [.git_mixin]
  variables:
    # Built-in
    GIT_STRATEGY: "clone"
    GIT_FETCH_EXTRA_FLAGS: "--jobs=${CORES_PER_JOB} --prune --no-tags"
    GIT_SUBMODULE_STRATEGY: "none"

.fetch_mixin:
  extends: [.git_mixin]
  variables:
    # Built-in
    GIT_STRATEGY: "none"
    GIT_CLONE_PATH: "${BUILDS}/${REPO_NAME}-${DOCKER_PLATFORM}-${BRANCH}"
    GIT_SUBMODULE_STRATEGY: "none"

###################################################
## Job Templates
###################################################
.job_template:
  variables:
    LOG_DIR: "./logs"
    JOB_LOG: "${LOG_DIR}/${JOB_NAME}.log"
    RPT_DIR: "./reports"
    JOB_RPT: "${RPT_DIR}/${JOB_NAME}.rpt"
  before_script:
    - echo "[CI] Refreshing log directory"
    - mkdir -p ${LOG_DIR} ${RPT_DIR} && rm -f ${JOB_LOG} ${JOB_RPT}
    - echo "[CI] Starting job ${JOB_GROUP_NAME}" | tee -a ${JOB_LOG}
  after_script:
    - |
      if [ $CI_JOB_STATUS == 'success' ]; then
        echo "[CI] job passed with status $CI_JOB_STATUS" | tee -a ${JOB_RPT}
      else
        echo "[CI] job failed with status $CI_JOB_STATUS" | tee -a ${JOB_RPT}
      fi
    - echo "[CI] Finishing job ${JOB_GROUP_NAME}" | tee -a ${JOB_LOG}
    - *git_unlock_fs_script
  artifacts:
    when: always
    paths:
      - "${JOB_LOG}"
      - "${JOB_RPT}"

## https://docs.gitlab.com/ee/user/packages/container_registry/build_and_push_images.html
.image_template:
  stage: docker
  extends: [.job_template, .clone_mixin]
  image: {name: "docker:24.0.5"}
  services: [docker:24.0.5-dind]
  tags: [saas-linux-small-amd64] # Use shared gitlab runner
  script:
    - echo "[CI] Logging into docker registry" | tee -a ${JOB_LOG}
    - echo "${REGISTRY_PASSWORD}" | docker login ${REGISTRY} -u ${REGISTRY_USER} --password-stdin
    - echo "[CI] Checking for previous docker image ${CONTAINER_IMAGE}" | tee -a ${JOB_LOG}
    - |
      if docker manifest inspect ${CONTAINER_IMAGE} > /dev/null 2>&1; then
        echo "[CI] ${CONTAINER_IMAGE} exists, pulling..." | tee -a ${JOB_LOG}
        docker pull ${CONTAINER_IMAGE}
      else
        echo "[CI] ${CONTAINER_IMAGE} does not exist, starting from scratch"  | tee -a ${JOB_LOG}
      fi
    - echo "[CI] Building image ${CONTAINER_IMAGE}" | tee -a ${JOB_LOG}
    - >
      docker build docker -f docker/Dockerfile.${DOCKER_PLATFORM}
      --build-arg BUILDKIT_INLINE_CACHE=1 --cache-from ${CONTAINER_IMAGE}
      --build-arg USER_NAME="${USER_NAME}"
      --build-arg USER_ID="${USER_ID}"
      --build-arg GROUP_NAME="${GROUP_NAME}"
      --build-arg GROUP_ID="${GROUP_ID}"
      --build-arg OTHER_GROUPS="${OTHER_GROUPS}"
      --build-arg WORKDIR="${WORKDIR}"
      -t ${CONTAINER_IMAGE} >> ${JOB_LOG} 2>&1
    - echo "[CI] Logging into docker registry"  | tee -a ${JOB_LOG}
    - echo "${REGISTRY_PASSWORD}" | docker login ${REGISTRY} -u ${REGISTRY_USER} --password-stdin
    - echo "[CI] Publishing docker images"  | tee -a ${JOB_LOG}
    - docker push ${CONTAINER_IMAGE}
  rules:
    - if: $FORCE_REBUILD
      when: always
    - changes:
        paths:
          - "docker/requirements.txt"
          - "docker/Dockerfile.${DOCKER_PLATFORM}"
          - "docker/entrypoint.${DOCKER_PLATFORM}.sh"

.build_template:
  extends: [.job_template, .fetch_mixin]
  tags: [bsg]
  stage: build
  variables:
    INSTALL_DIR: "install-${TOOL}"
    WORK_DIR: "work"
    INSTALL_TGZ: "${INSTALL_DIR}-${TOOL}-${DOCKER_PLATFORM}.tar.gz"
    # Exported to make sure things go in the right place
    BP_TOOLS_WORK_DIR: "${CI_PROJECT_DIR}/${WORK_DIR}"
    BP_TOOLS_INSTALL_DIR: "${CI_PROJECT_DIR}/${INSTALL_DIR}"
    # https://gitlab.com/gitlab-org/gitlab-runner/-/issues/1736#note_107983504
    FF_DISABLE_UMASK_FOR_DOCKER_EXECUTOR: "true"
  image: {name: "${CONTAINER_IMAGE}"}
  script:
    - echo "[CI] Locking for git operation" | tee -a ${JOB_LOG}
    - *git_lock_script
    - echo "[CI] Fetching repository" | tee -a ${JOB_LOG}
    - *git_fetch_script
    - echo "[CI] Doing basic checkout" | tee -a ${JOB_LOG}
    - *git_checkout_script
    - echo "[CI] Doing makefile checkout" | tee -a ${JOB_LOG}
    - make -C ${GIT_SRC_DIR} -j${CORES_PER_JOB} checkout >> ${JOB_LOG} 2>&1
    - echo "[CI] Doing patching" | tee -a ${JOB_LOG}
    - make -C ${GIT_SRC_DIR} -j${CORES_PER_JOB} repatch.${TOOL} >> ${JOB_LOG} 2>&1
    - echo "[CI] Unlocking..." | tee -a ${JOB_LOG}
    - *git_unlock_script
    - echo "[CI] Rebuilding ${TOOL}" | tee -a ${JOB_LOG}
    - make -C ${GIT_SRC_DIR} -j${CORES_PER_JOB} rebuild.${TOOL} >> ${JOB_LOG} 2>&1
    - echo "[CI] Zipping ${TOOL} installation" | tee -a ${JOB_LOG}
    - tar -czvf ${INSTALL_TGZ} ${INSTALL_DIR}/ >> ${JOB_LOG} 2>&1
  artifacts:
    when: always
    paths:
      - "${JOB_LOG}"
      - "${JOB_RPT}"
      - "${INSTALL_TGZ}"

.publish_template:
  extends: [.job_template, .bare_mixin]
  stage: publish
  variables:
    INSTALL_DIR: "install"
    PUBLISH_TGZ: "install-${SHA}.tar.gz"
    PROJECT_URL: "${API_URL}/projects/${PROJECT_ID}"
    PACKAGE_URL: "${PROJECT_URL}/packages/generic/${DOCKER_PLATFORM}"
    PUBLISH_URL: "${PACKAGE_URL}/${BRANCH}/${PUBLISH_TGZ}"
  script:
    - |
      echo "[CI] archives found\n$(ls *.tar.gz)"
      for f in *-${DOCKER_PLATFORM}.tar.gz; do
        tar -xzf $f >> ${JOB_LOG} 2>&1
      done
    - echo "[CI] Zipping installation ${PUBLISH_TGZ}"
    - tar -czvf ${PUBLISH_TGZ} ${INSTALL_DIR}-*/ >> ${JOB_LOG} 2>&1
    - echo "[CI] Publishing ${PUBLISH_TGZ} to ${PACKAGE_URL}"
    - |
      curl --location --header "JOB-TOKEN: ${JOB_TOKEN}" \
           --upload-file ${PUBLISH_TGZ} \
           "${PUBLISH_URL}"

###################################################
## Actual Jobs
###################################################

# We couple dependencies here while we wait for this feature
# https://gitlab.com/gitlab-org/gitlab/-/issues/423456
# needs:
#  parallel:
#    matrix:
#      - DOCKER_PLATFORM: $DOCKER_PLATFORM

image-tools:
  extends: [.image_template]
  rules: !reference [.image_template, rules]
  parallel:
    matrix:
      - DOCKER_PLATFORM: ["ubuntu24.04", "centos7"]

build-tools:
  extends: [.build_template]
  parallel:
    matrix:
      - DOCKER_PLATFORM: ["ubuntu24.04", "centos7"]
        TOOL: ["boost", "verilator", "dromajo"]
      - DOCKER_PLATFORM: ["ubuntu24.04", "centos7"]
        TOOL: ["spike", "surelog", "yslang", "axe"]
      - DOCKER_PLATFORM: ["ubuntu24.04", "centos7"]
        TOOL: ["bsg_sv2v", "bsg_fakeram"]

publish-tools:
  extends: [.publish_template]
  parallel:
    matrix:
      - DOCKER_PLATFORM: ["ubuntu24.04", "centos7"]


