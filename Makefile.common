
# Global Makefile settings
# Saves initial values so that we can filter them later
# MUST BE FIRST
VARS_OLD := $(.VARIABLES)
SHELL := /bin/bash
EXTRAMAKEFLAGS += --warn-undefined-variables
MAKEFLAGS += $(EXTRAMAKEFLAGS)
.DEFAULT_GOAL: help

#############################
# Environment detection
#############################
CENTOS7 := $(if $(findstring CentOS Linux release 7,$(shell cat /etc/centos-release 2>/dev/null)),1,0)
ARMV7 := $(if $(findstring armv7l,$(shell /usr/bin/arch)),1,0)
AARCH64 := $(if $(findstring aarch64,$(shell /usr/bin/arch)),1,0)
ARM := $(if $(ARMV7),1,$(if $(AARCH64),1,0))
UBUNTU24 := $(if $(findstring Ubuntu 24,$(shell lsb_release -a 2>/dev/null)),1,0)

#############################
# Makefile variables templates
#############################

bsg_var_blank :=
define bsg_var_newline

$(bsg_var_blank)
endef

bsg_var_percent := %

#############################
# Makefile function templates
#############################
define bsg_fn_upper
$(shell echo $(1) | tr a-z A-Z)
endef

define bsg_fn_lower
$(shell echo $(1) | tr A-Z a-z)
endef

define bsg_fn_patch_if_new
	$(eval apply_stage_patch := git apply --ignore-whitespace --ignore-space-change)
	$(eval apply_commit_patch := git am --ignore-whitespace --ignore-space-change)
	$(eval check_patch := $(apply_stage_patch) --check --reverse)
	$(eval src_root := $(1))
	$(eval patch_root := $(2))
	$(eval patch_list := $(wildcard $(patch_root)/*.patch))
	$(eval patch_is_top := $(findstring patches,$(lastword $(subst /, ,$(dir $(patch_root))))))
	for p in $(patch_list); \
	do \
		echo "Checking if patch $$p is applicable"; \
		cd $(src_root); $(check_patch) $$p && continue; \
		echo "Patch is unapplied..."; \
		if [ ! -z "$$patch_is_top" ]; then \
			echo "Applying patch to sub-directory $(src_root);" \
			cd $(src_root); $(apply_commit_patch) $$p; \
			echo "Patch applied!"; \
		else \
			echo "Applying patch to top-level $(src_root);" \
			cd $(src_root); $(apply_stage_patch) $$p; \
			echo "Patch applied!"; \
		fi \
	done
endef

define bsg_fn_mksubdir
	$(eval hookdirs := $(1))
	$(eval newvars := $(filter-out $(VARS_OLD),$(.VARIABLES)))
	$(eval bpvars := $(filter BP_%,$(newvars)))
	$(eval newdirs := $(foreach root,$(hookdirs),\
		$(foreach var,$(bpvars),\
			$(if $(filter $(root)%,$($(var))),\
				$($(var))))\
		)\
	)
	mkdir -p $(hookdirs)
	mkdir -p $(newdirs)
endef

define bsg_fn_disable_submodules
	$(eval subs := $(1))
	for t in $(subs); do \
		d=$$(echo $$t | cut -d '@' -f 1); \
		s=$$(echo $$t | cut -d '@' -f 2); \
		echo "Disabling checkout for $$d/$$s"; \
		git -C $$d config --local submodule.$$s.update none; \
		git -C $$d submodule sync --recursive; \
	done
endef

define bsg_fn_info
	$(eval $@_msg = $(1))
	$(eval $@_prefix = "BSG-INFO: ")
	echo "${$@_prefix} ${$@_msg}";
endef

define bsg_fn_warn
	$(eval $@_msg = $(1))
	$(eval $@_prefix = "BSG-WARN: ")
	echo "${$@_prefix} ${$@_msg}";
endef

define bsg_fn_error
	$(eval $@_msg = $(1))
	$(eval $@_prefix = "BSG-ERROR: ")
	echo "${$@_prefix} ${$@_msg}"; \
	exit -1;
endef

#############################
# Makefile target templates
#############################

define bsg_tgt_build_tag
	$(eval name := $(1))
	$(eval src_dir := $(2))
	$(eval touch_dir := $(3))
	$(eval patch_dir := $(4))
	$(eval tag := $(5))
	$(eval patch_tag := $(touch_dir)/$(name).patch.$(tag))
	$(eval build_tag := $(touch_dir)/$(name).build.$(tag))
	$(eval patch_root := $(patch_dir)/$(lastword $(src_dir)))
	$(eval patch_target := patch.$(name))
	$(eval repatch_target := repatch.$(name))
	$(eval external_target := build.$(name))
	$(eval rebuild_target := rebuild.$(name))
	$(eval internal_target := $(src_dir)/.$(name)_build)
	$(eval MAKEFLAGS := $(filter-out $(EXTRAMAKEFLAGS),$(MAKEFLAGS)))
$(external_target): | $(build_tag)
$(rebuild_target):
	rm -f $(touch_dir)/$(name).build.*
	+$(MAKE) $(build_tag)
$(build_tag): | $(patch_tag)
	+$(MAKE) $(patch_target)
	+$(MAKE) $(internal_target)
	echo "Build of $(name) successful; ignore errors"
	touch $(build_tag)
$(patch_target): | $(patch_tag)
$(repatch_target):
	rm -f $(touch_dir)/$(name).patch.*
	if [ -f $(src_dir)/.git ]; then \
		git submodule deinit -f $(src_dir); \
		git submodule init $(src_dir); \
		git submodule update $(src_dir); \
	fi
	+$(MAKE) $(patch_tag)
$(patch_tag):
	if [ -f $(src_dir)/.git ]; then \
		echo "Synchronizing submodules for $(1)"; \
		git -C $(src_dir) submodule sync --recursive; \
		echo "Checking out submodules for $(1)"; \
		git -C $(src_dir) submodule update --init --recursive; \
	fi
	$(call bsg_fn_patch_if_new,$(src_dir),$(patch_root))
	echo "Patching successful; ignore errors"
	touch $(patch_tag)
endef

define bsg_tgt_build_if_new
	$(eval name := $(1))
	$(eval src_dir := $(2))
	$(eval touch_dir := $(3))
	$(eval patch_dir := $(4))
	$(eval tag := $(shell cd $(src_dir); git rev-parse HEAD))
	$(call bsg_tgt_build_tag,$(name),$(src_dir),$(touch_dir),$(patch_dir),$(tag))
endef

define bsg_tgt_build_if_missing
	$(eval name := $(1))
	$(eval src_dir := $(2))
	$(eval touch_dir := $(3))
	$(eval patch_dir := $(4))
	$(eval tag := any)
	$(call bsg_tgt_build_tag,$(name),$(src_dir),$(touch_dir),$(patch_dir),$(tag))
endef

#############################
# Makefile targets
#############################
# Global help target
.PHONY: help
help: ## prints this message
	@egrep -h '\s##\s' $(MAKEFILE_LIST) | sort \
		| awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m  %-30s\033[0m %s\n", $$1, $$2}'

# Global reset
.PHONY: bleach_all
bleach_all: ## wipes the whole repo clean. Use with caution
	@git -C "$(git rev-parse --show-toplevel)" submodule deinit -f .
	@git -C "$(git rev-parse --show-toplevel)" clean -ffdx

# Global checkout
.PHONY: checkout
checkout: ## checkout submodules
	@$(call bsg_fn_mksubdir,$(HOOK_CHECKOUT_DIRS))
	# Synchronize any pending updates
	@git submodule sync
	@git submodule init
	# Disable long checkouts
	$(call bsg_fn_disable_submodules,$(HOOK_DISABLE_SUBMODULES))
	# Do the checkout
	@git submodule update

##########################################################
## Cad environment
##########################################################

## Override CAD tool paths if needed
VCS       ?= vcs
URG       ?= urg
VERILATOR ?= verilator
DC_SHELL  ?= dc_shell
VIVADO    ?= vivado
_DVE      ?= dve
GTKWAVE   ?= gtkwave
YOSYS     ?= yosys
## Specify license path if needed
VCS_HOME        ?=
LM_LICENSE_FILE ?=

ifneq ($(MAKECMDGOALS),help)
BSG_CADENV_DIR ?= bsg_cadenv
include $(BSG_CADENV_DIR)/cadenv.mk
%/cadenv.mk:
	# BSG users leverage a machine-specific cadenv
	#   Here, we add sourcing to get these variables as well
	@$(eval export CADENV_URL := git@github.com:bespoke-silicon-group/bsg_cadenv)
	# Recursive make to include the new fragment
	@if [ -f "$(BSG_CADENV_DIR)/cadenv.mk" ]; then \
		echo "bsg_cadenv already exists"; \
	elif [[ ! -z $$(git ls-remote --exit-code $${CADENV_URL} HEAD 2> /dev/null) ]]; then \
		git clone --recurse-submodules $${CADENV_URL} $(@D); \
	else \
		echo "bsg_cadenv not found"; \
		mkdir -p $(@D); \
		touch $@; \
	fi
	@echo "Successfully built $@!"
endif

##########################################################
## Other tools
##########################################################
CAT       ?= cat
CMAKE     ?= $(if $(shell which cmake3),cmake3,cmake)
CD        ?= cd
CP        ?= cp
CURL      ?= curl
DIFF      ?= diff
DOCKER    ?= docker
ECHO      ?= echo
ENVSUBST  ?= envsubst
EXIT      ?= exit
FIND      ?= find
GCC       ?= gcc
GIT       ?= git
GREP      ?= grep
MKDIR     ?= mkdir
MV        ?= mv
PRINTF    ?= printf
PYTHON    ?= $(if $(shell which python3),python3,python)
RM        ?= rm
RMRF      ?= rm -rf
SED       ?= sed
STTY      ?= stty
SYMLINK   ?= ln -nsf
TAIL      ?= tail
TAR       ?= tar
TEE       ?= tee
TEST      ?= test
TOUCH     ?= touch
WCOUNT    ?= wc -l
WGET      ?= wget
XXD       ?= xxd

